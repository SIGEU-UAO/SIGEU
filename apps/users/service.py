from django.db import IntegrityError
from django.contrib.auth.models import Group
from django.contrib.auth.hashers import check_password
from django.db.models import Q, Value, Case, When, CharField
from django.db.models.functions import Concat
import re
from .models import *

# Password history limit
PASSWORD_HISTORY_LIMIT = 3

def validate_new_password(user, new_password):
    """
    Validates that the new password is not the same as the current one or the last N used by the user.
    """

    if not re.match(r'^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[a-zA-Z]).{8,}$', new_password):
        raise ValueError("La nueva contraseña debe tener al menos 8 caracteres, incluyendo letras y números.")

    if not new_password:
        raise ValueError("La nueva contraseña es requerida.")

    # Compare with the current one
    if check_password(new_password, user.password):
        raise ValueError("No puede ser igual a la actual.")

    # Compare with the last N passwords
    historial = (
        Contrasenia.objects
        .filter(idUsuario=user)
        .order_by('-fechaCambio')[:PASSWORD_HISTORY_LIMIT]
    )
    for h in historial:
        if check_password(new_password, h.clave):
            raise ValueError("Esta contraseña ya ha sido utilizada anteriormente.")

    return True


def save_password_history(user):
    
    # Register new password (current hash)
    Contrasenia.objects.create(idUsuario=user, clave=user.password, es_activa=True)

    # Keep only the last N
    ids_a_conservar = list(
        Contrasenia.objects
        .filter(idUsuario=user)
        .order_by('-fechaCambio')
        .values_list('idContrasenia', flat=True)[:PASSWORD_HISTORY_LIMIT]
    )
    if ids_a_conservar:
        Contrasenia.objects.filter(idUsuario=user).exclude(idContrasenia__in=ids_a_conservar).delete()


class UserService:
    @staticmethod
    def registrar(data):
        rol = data.get("rol")

        try:
            usuario = Usuario.objects.create_user(
                email=data["email"],
                password=data["password"],
                nombres=data["nombres"],
                apellidos=data["apellidos"],
                telefono=data["telefono"],
                numeroIdentificacion=data["numeroIdentificacion"],
            )
        except IntegrityError as e:
            s = str(e).lower()
            if "email" in s:
                raise ValueError("El correo electrónico ya está registrado.") from e
            if "numeroidentificacion" in s or "numero_identificacion" in s:
                raise ValueError("El documento de identidad ya está registrado.") from e
            if "telefono" in s or "phone" in s:
                raise ValueError("El teléfono ya está registrado.") from e
            raise ValueError("Datos duplicados en el usuario.") from e
        
        # --- Guardar la contraseña inicial en el historial ---
        Contrasenia.objects.create(
            idUsuario=usuario,
            clave=usuario.password,  # hash generated by set_password
            es_activa=True,
        )

        # --- Crear el registro según el rol; si falla, limpiar al usuario ---
        try:
            if rol == "estudiante":
                programa = Programa.objects.get(pk=data["programa_id"])
                estudiantes = Group.objects.get(name="Estudiantes")      
                Estudiante.objects.create(usuario=usuario, codigo_estudiante=data["codigo_estudiante"], programa=programa)
                usuario.groups.add(estudiantes)

            elif rol == "docente":
                docentes = Group.objects.get(name="Docentes") 
                unidad = UnidadAcademica.objects.get(pk=data["unidad_academica_id"])
                Docente.objects.create(usuario=usuario, unidadAcademica=unidad)
                usuario.groups.add(docentes) 

            elif rol == "secretaria":
                secretarias = Group.objects.get(name="Secretarias") 
                facultad = Facultad.objects.get(pk=data["facultad_id"])
                Secretaria.objects.create(usuario=usuario, facultad=facultad)
                usuario.groups.add(secretarias)

        except (Programa.DoesNotExist, UnidadAcademica.DoesNotExist, Facultad.DoesNotExist) as e:
            usuario.delete()
            raise ValueError("ID relacionado inválido para el rol seleccionado.") from e

        except IntegrityError as e:
            usuario.delete()
            s = str(e).lower()
            if "codigo_estudiante" in s or "codigo" in s:
                raise ValueError("El código de estudiante ya existe.") from e
            raise ValueError("Datos duplicados para el registro del rol.") from e

        except Exception as e:
            usuario.delete()
            raise

        return usuario.idUsuario

    @staticmethod
    def cambiar_password(user, new_password):
        """
        Changes the user's password validating against history.
        """
        validate_new_password(user, new_password)
        user.set_password(new_password)
        user.save()
        save_password_history(user)
        return True
    

    @staticmethod
    def listar_organizadores():
        return Usuario.objects.filter(
            Q(docente__isnull=False) | Q(estudiante__isnull=False)
        ).annotate(
            nombre_completo=Concat('nombres', Value(' '), 'apellidos'),
            rol=Case(
                When(estudiante__isnull=False, then=Value('Estudiante')),
                When(docente__isnull=False, then=Value('Docente')),
                default=Value('Usuario'),
                output_field=CharField()
            )
        ).values("idUsuario", "nombre_completo", "numeroIdentificacion", "rol")

    @staticmethod
    def filtrar_organizadores_por_nombre_completo(nombre_completo, usuario_actual_id=None):
        if not nombre_completo:
         return []
        
        qs = (
            Usuario.objects
            .filter(Q(docente__isnull=False) | Q(estudiante__isnull=False))  # Solo organizadores
            .annotate(
                nombre_completo=Concat('nombres', Value(' '), 'apellidos'), # Añadir propiedad nombre completo
                rol=Case(                                                   # Añadir propiedad rol
                    When(estudiante__isnull=False, then=Value('Estudiante')),
                    When(docente__isnull=False, then=Value('Docente')),
                    default=Value('Usuario'),
                    output_field=CharField()
                )
            )
            .filter(nombre_completo__icontains=nombre_completo)
            .values("idUsuario", "nombre_completo", "numeroIdentificacion", "rol")
        )

        if usuario_actual_id:
            qs = qs.exclude(idUsuario=usuario_actual_id)

        return list(qs.values("idUsuario", "nombre_completo", "numeroIdentificacion", "rol"))
    
    # * This method allows you to obtain a user as an instance of the model.
    @staticmethod
    def obtener_instance_por_id(id_usuario):
        try:
            usuario = Usuario.objects.get(idUsuario=id_usuario)
            return usuario
        except Usuario.DoesNotExist:
            return False

    # * This method allows you to obtain a user as an object because it includes the role
    @staticmethod
    def obtener_organizador_por_id(id_usuario):
        try:
            usuario = (
                Usuario.objects
                .filter(Q(estudiante__isnull=False) | Q(docente__isnull=False))  # solo organizadores
                .annotate(
                    rol=Case(
                        When(estudiante__isnull=False, then=Value('Estudiante')),
                        When(docente__isnull=False, then=Value('Docente')),
                        default=Value('Usuario'),
                        output_field=CharField()
                    )
                )
                .values("idUsuario", "numeroIdentificacion", "nombres", "apellidos", "email", "telefono", "rol")
                .get(idUsuario=id_usuario)
            )

            return usuario
        except Usuario.DoesNotExist:
            return False